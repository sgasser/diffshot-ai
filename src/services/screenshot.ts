import { query } from '@anthropic-ai/claude-code';
import path from 'path';
import { fileURLToPath } from 'url';
import 'dotenv/config';
import { DiffShotOptions, DiffShotResult, Message } from '../types/index.js';
import { CONFIG, ENV_VARS } from '../config/index.js';
import {
  logger,
  formatMessage,
  configExists,
  readFile,
  fileExists,
  listFiles,
  generateMarkdownSummary,
  loadPromptTemplate,
} from '../utils/index.js';

const CAPTURE_SCRIPT_PATH = (() => {
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = path.dirname(__filename);
  return path.join(__dirname, '..', 'scripts', 'capture-screenshot.js');
})();

const AUTH_ERROR_MESSAGE = 'Claude Code process exited with code 1';
const DIFFSHOT_SIGNATURE = '\n\n*Generated by [DiffShot](https://github.com/sgasser/diffshot) ðŸ¤–*';

interface ClaudeQueryOptions {
  prompt: string;
  workDir: string;
  allowedTools: string[];
}

interface ProcessState {
  lastAssistantMessage: string;
  processInterrupted: boolean;
  handleInterrupt: () => void;
}

/**
 * Check if authentication is available
 */
function checkAuthentication(): boolean {
  if (!process.env[ENV_VARS.API_KEY] && !process.env.CLAUDE_CODE_OAUTH_TOKEN) {
    logger.error('No authentication found');
    logger.info('\nYou need to set one of these environment variables:');
    logger.info('\nOption 1: Anthropic API Key (from https://console.anthropic.com/)');
    logger.info(`  export ${ENV_VARS.API_KEY}=sk-ant-api...\n`);
    logger.info('Option 2: Claude Code OAuth Token');
    logger.info('  export CLAUDE_CODE_OAUTH_TOKEN=sk-ant-oat...');
    return false;
  }
  return true;
}

/**
 * Validate configuration exists
 */
async function validateConfiguration(workDir: string): Promise<string | null> {
  const configPath = path.join(workDir, CONFIG.FILE_NAME);

  if (!configExists(workDir)) {
    logger.error(`${CONFIG.FILE_NAME} not found. Run "diffshot-ai init" first.`);
    return null;
  }

  try {
    return await readFile(configPath);
  } catch (error) {
    logger.error(`Failed to read ${CONFIG.FILE_NAME}: ${error}`);
    return null;
  }
}

/**
 * Setup process interrupt handlers
 */
function setupInterruptHandlers(): ProcessState {
  const state: ProcessState = {
    lastAssistantMessage: '',
    processInterrupted: false,
    handleInterrupt: () => {
      state.processInterrupted = true;
      logger.warning('\nProcess interrupted by user');
    },
  };

  process.on('SIGINT', state.handleInterrupt);
  process.on('SIGTERM', state.handleInterrupt);

  return state;
}

/**
 * Cleanup interrupt handlers
 */
function cleanupInterruptHandlers(handleInterrupt: () => void): void {
  process.removeListener('SIGINT', handleInterrupt);
  process.removeListener('SIGTERM', handleInterrupt);
}

/**
 * Extract text content from Claude message
 */
function extractTextFromMessage(message: Message): string {
  if (message.type !== 'assistant' || !message.message?.content) {
    return '';
  }

  let text = '';
  for (const content of message.message.content) {
    if (content.type === 'text' && content.text?.trim()) {
      text += content.text.trim() + '\n\n';
    }
  }

  return text;
}

/**
 * Run Claude query and process messages
 */
async function runClaudeQuery(options: ClaudeQueryOptions, state: ProcessState): Promise<void> {
  const queryOptions = {
    prompt: options.prompt,
    options: {
      cwd: options.workDir,
      permissionMode: 'bypassPermissions' as const,
      allowedTools: options.allowedTools,
    },
  };

  for await (const message of query(queryOptions)) {
    if (state.processInterrupted) {
      break;
    }

    const formatted = formatMessage(message, options.workDir);
    if (formatted) {
      process.stdout.write(formatted);
    }

    const messageText = extractTextFromMessage(message);
    if (messageText) {
      state.lastAssistantMessage = messageText;
    }
  }
}

/**
 * Count screenshots in output directory
 */
async function countScreenshots(workDir: string): Promise<string[]> {
  const outputDir = path.join(workDir, CONFIG.SCREENSHOT_DIR);

  if (!(await fileExists(outputDir))) {
    return [];
  }

  const files = await listFiles(outputDir);
  return files.filter((f) => f.endsWith('.png') && f !== 'init.png');
}

/**
 * Run change analysis
 */
async function runChangeAnalysis(changedFiles: string[], workDir: string): Promise<string> {
  try {
    const prompt = await loadPromptTemplate('change-analysis.md', {
      changedFiles: changedFiles.map((f) => `- ${f}`).join('\n'),
      workDir,
    });

    let analysis = '';
    for await (const message of query({
      prompt,
      options: {
        cwd: workDir,
        permissionMode: 'bypassPermissions' as const,
        allowedTools: ['Bash', 'Read', 'Grep'],
      },
    })) {
      analysis += extractTextFromMessage(message);
    }

    return analysis.trim();
  } catch {
    logger.info('Could not analyze changes');
    return '';
  }
}

/**
 * Generate final markdown summary
 */
async function generateFinalMarkdown(
  claudeMarkdown: string,
  changedFiles: string[],
  workDir: string,
  branch: string,
  changeAnalysis: string,
  screenshots: string[]
): Promise<string> {
  const markdownResult = claudeMarkdown
    ? { summary: claudeMarkdown, screenshots }
    : await generateMarkdownSummary(changedFiles, workDir, branch, changeAnalysis);

  return markdownResult.summary + DIFFSHOT_SIGNATURE;
}

/**
 * Handle authentication error
 */
function handleAuthenticationError(): void {
  logger.error('Authentication failed');
  logger.info('\nThis usually means your API key or OAuth token is invalid.');
  logger.info('\nPlease check:');
  logger.info('  1. Your API key/token is correct and not expired');
  logger.info('  2. You have access to the Claude API');
  logger.info('\nCurrent authentication source: Check your .env file or environment variables');
}

/**
 * Handle generic error
 */
function handleGenericError(error: unknown): string {
  const errorMessage = error instanceof Error ? error.message : String(error);

  logger.error(`Error: ${errorMessage}`);
  if (error instanceof Error && error.stack) {
    logger.error('Stack trace: ' + error.stack);
  }

  return errorMessage;
}

/**
 * Run DiffShot to generate screenshots based on code changes
 * @param options - Configuration options for DiffShot
 * @returns Result object indicating success/failure and details
 */
export async function runDiffShot(options: DiffShotOptions = {}): Promise<DiffShotResult> {
  const { changedFiles = [], workDir = process.cwd(), branch = 'UNCOMMITTED' } = options;

  if (!checkAuthentication()) {
    return { success: false };
  }

  const diffShotConfig = await validateConfiguration(workDir);
  if (!diffShotConfig) {
    return { success: false };
  }

  if (changedFiles.length === 0) {
    logger.info('No changed files to process');
    return { success: true, scenarios: 0, screenshots: 0 };
  }

  const state = setupInterruptHandlers();

  try {
    const prompt = await loadPromptTemplate('screenshot.md', {
      diffShotConfig,
      changedFiles: changedFiles.map((f) => `- ${f}`).join('\n'),
      captureScriptPath: CAPTURE_SCRIPT_PATH,
      workDir,
    });

    logger.info('\nStarting Claude Code analysis...');

    await runClaudeQuery(
      {
        prompt,
        workDir,
        allowedTools: ['Read', 'Grep', 'Glob', 'LS', 'TodoWrite', 'Bash'],
      },
      state
    );

    cleanupInterruptHandlers(state.handleInterrupt);

    if (state.processInterrupted) {
      return { success: false, error: 'Process interrupted by user' };
    }

    const screenshots = await countScreenshots(workDir);

    logger.success('\nScreenshot generation complete!');
    if (screenshots.length > 0) {
      logger.success(`Generated ${screenshots.length} screenshots`);
    }

    const changeAnalysis = await runChangeAnalysis(changedFiles, workDir);

    const finalMarkdownSummary = await generateFinalMarkdown(
      state.lastAssistantMessage.trim(),
      changedFiles,
      workDir,
      branch,
      changeAnalysis,
      screenshots
    );

    return {
      success: true,
      screenshots: screenshots.length,
      outputDir: path.join(workDir, CONFIG.SCREENSHOT_DIR),
      markdownSummary: finalMarkdownSummary,
    };
  } catch (error) {
    cleanupInterruptHandlers(state.handleInterrupt);

    const errorMessage = error instanceof Error ? error.message : String(error);

    if (errorMessage.includes(AUTH_ERROR_MESSAGE)) {
      handleAuthenticationError();
    } else {
      handleGenericError(error);
    }

    return { success: false, error: errorMessage };
  }
}
